{"meta":{"title":"white-cc","subtitle":"","description":"","author":"white-cc","url":"http://yoursite.com","root":"/"},"pages":[{"title":"search","date":"2020-05-18T07:00:45.000Z","updated":"2020-05-18T07:01:10.698Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-20T02:47:49.000Z","updated":"2021-01-25T12:24:37.608Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 二次元重症患者 初入互联网行业小萌新"},{"title":"categories","date":"2020-05-18T06:53:33.000Z","updated":"2020-05-18T07:09:53.644Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-18T06:54:15.000Z","updated":"2020-05-18T06:55:55.688Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"用c++实现http服务器1","slug":"用c++实现http服务器1","date":"2022-03-26T08:31:29.000Z","updated":"2022-03-26T09:26:08.438Z","comments":true,"path":"2022/03/26/用c++实现http服务器1/","link":"","permalink":"http://yoursite.com/2022/03/26/%E7%94%A8c++%E5%AE%9E%E7%8E%B0http%E6%9C%8D%E5%8A%A1%E5%99%A81/","excerpt":"使用c++实现使用socket接口，通过http协议调用CGI的多线程http server","text":"使用c++实现使用socket接口，通过http协议调用CGI的多线程http server HTTP 服务端CGI架构设计 123456Title: CGI调用方式客户端-&gt;服务端: 发出http请求服务端-&gt;客户端: 返回http响应服务端-&gt;CGI: 创建响应线程,fork()子进程，使用pipe与子进程通讯，并重定向输入输出，exec装载对应程序。CGI-&gt;服务端: 服务器端读取CGI输出，并写入tcp流Note right of 服务端: 服务端 建立tcp服务端，监听对应端口，根据客户端请求建立起新的线程 服务启动时创建TCP的socket，通过bind()绑定对应端口，使用setscokopt设置相应参数,使用listen()来开启监听; 当accept()获取到客户端的tcp请求创建响应线程，并解析http请求。 确认为http请求后，如果请求为非CGI，则直接返回对应的文件。 如果为CGI请求，则线程fork()子进程，pipe创建管道，读recv(),写send()字节套，并通过管道与子进程通讯。 子进程的标准输入输出重定向到管道中，并exec()将对应CGI装载入进程当中。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"MYSQL事务的隔离等级与实现","slug":"MYSQL事务的隔离等级与实现","date":"2021-11-16T15:21:10.000Z","updated":"2021-11-16T15:24:46.603Z","comments":true,"path":"2021/11/16/MYSQL事务的隔离等级与实现/","link":"","permalink":"http://yoursite.com/2021/11/16/MYSQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"一.事务的ACID特性 atomic原子性：操作要么成功要么失败。 consistency一致性：事务的开始与结束后事务的完整性没有遭到破坏。 isolation隔离性：事务可能并发执行，但事务之间不会相互感知。 durability持久性：事务完成后对于数据库的改变是永久的。","text":"一.事务的ACID特性 atomic原子性：操作要么成功要么失败。 consistency一致性：事务的开始与结束后事务的完整性没有遭到破坏。 isolation隔离性：事务可能并发执行，但事务之间不会相互感知。 durability持久性：事务完成后对于数据库的改变是永久的。 二.事务的隔离等级与其解决的问题 脏读 不可重复读 幻读 读未提交 RU YES YES YES 读已提交 RC NO YES YES 可重复读 RR NO NO YES 可串行化 Serializable NO YES NO 脏读：在读未提交的过程中，一个事务A读到了事务B的改变的值，但事务B最后回滚了，那么事务A就读到的是一个不能存在的值。 不可重复读：事务A在第一次读取值a时，事务B并没有改变事务a的取值。在第一次读取之后，事务B完成了commit，那么事务A再次读取A值时。会发现两次读取的结果不相同。 幻读： 事务A在读取一系列表记录时，记录s还没有插入到表记录中。此时事务A的读取中没有记录s，但是再次读取时会发现出现了记录s，就像出现了幻觉。所以被称为幻读。 通过加锁的方式来实现不同的事务隔离级别 读未提交 读 写 读 YES YES 写 YES NO ​ 在RU中可能会读到其他事务未提交的数据，如果事务回滚可能会产生脏读，只存在写写互斥。 2.读已提交 读 写 读 YES YES 写 YES NO ​ 在RC中只能读取已提交数据，但是依然没有读写锁。所以导致同一事务在两次读取同一记录产生不一致的情况。也就是不可重复读。 可重复读 读 写 读 YES NO 写 NO NO ​ 在RR隔离等级当中出现了读锁，即mysql当中以 共享锁 。读锁不互斥，读写锁相互互斥。共享锁可以由多个事务同时获取，但是当两个即以上的事务持有改记录的共享锁时，当前记录是只读的。对于一个不存在的记录是无法进行加锁，当有新纪录加入时，会使一个事务两次读取产生不同的结果，也就是会出现幻读。 可串行化 完全串行化的读，每次读写都需要获得表级共享锁，读写相互都会阻塞。 但是在mysql当中一定是这样实现的么？ 三. MYSQL当中不同的锁 1.共享锁 123456789--共享锁BEGIN;SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 LOCK IN SHARE MODE;UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&quot;aa1&quot; WHERE &#96;id&#96; &#x3D; 1 ;COMMIT;--干扰项-- BEGIN;-- SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 LOCK IN SHARE MODE;-- COMMIT; 当有两个以上事务获得同一记录的共享锁时则为只可进行读操作。如干扰项加锁后，第一个事务执行update语句将被blocked掉，直到第二个事务被提交后才可以运行。 2.记录锁 12345--排它锁BEGIN;SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 FOR UPDATE;UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&quot;aa1&quot; WHERE &#96;id&#96; &#x3D; 1 ;COMMIT; 记录锁为排它锁，获取锁后其余关于该记录的操作都会被blocked掉。 当然，如果该条记录有共享锁时，是无法被获取排它锁的。 3.自增锁 12345678--自增锁BEGIN;INSERT INTO &#96;student&#96; (&#96;name&#96;) VALUES(&#39;C1-SE&#39;);COMMIT;BEGIN;INSERT INTO &#96;student&#96; (&#96;name&#96;) VALUES(&#39;C2-FI&#39;);COMMIT; 执行事务1的插入语句但不提交，执行事务二的插入语句后并提交，会发现C1-SE的id比C2-F1的id大。 4.间隙锁 1234567BEGIN;SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; &gt; 1 FOR UPDATE;SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; BETWEEN 5 AND 7 FOR UPDATE;COMMIT; 间隙锁，在RR级事务下有效。通过锁一个区域的记录来防止幻读。 四. 再回头看MYSQL又是如何解决这些问题？ 不通过加锁实现可重复读。 通过MVCC来实现读写分离，并解决可重复读问题。 12345678910BEGIN ;SELECT *FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 ;SELECT *FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 ;COMMIT;BEGIN;SELECT * FROM &#96;student&#96; WHERE &#96;id&#96; &#x3D; 1 FOR UPDATE;UPDATE &#96;student&#96; SET &#96;name&#96;&#x3D;&quot;aaa1&quot; WHERE &#96;id&#96; &#x3D; 1 ;COMMIT; 在RR隔离下第二条事务提交前后都进行第一条事务的一次查询，会发现两次的结果都是旧数据，而不是已经更新的数据。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"go micro笔记1","slug":"go-micro笔记1","date":"2021-10-07T03:28:24.000Z","updated":"2021-10-07T04:51:54.867Z","comments":true,"path":"2021/10/07/go-micro笔记1/","link":"","permalink":"http://yoursite.com/2021/10/07/go-micro%E7%AC%94%E8%AE%B01/","excerpt":"","text":"go-micro 微服务开发中文手册 · 看云 (kancloud.cn) etcd中文文档 | 常见问题解答 [译]用GoLang实现微服务（一） - 二向箔 (dingkewz.com) Create versatile Microservices in Golang - part 1 of 10 part series (ewanvalentine.io)","categories":[],"tags":[]},{"title":"grpc学习笔记(Go实现)客户端","slug":"grpc学习笔记-Go实现-客户端","date":"2021-09-14T12:19:46.000Z","updated":"2021-09-14T12:27:18.993Z","comments":true,"path":"2021/09/14/grpc学习笔记-Go实现-客户端/","link":"","permalink":"http://yoursite.com/2021/09/14/grpc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Go%E5%AE%9E%E7%8E%B0-%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"grpc学习笔记(Go实现)客户端 客户端只用进行代码的调用","text":"grpc学习笔记(Go实现)客户端 客户端只用进行代码的调用 AddBlog 12345678//add one blog testbook1 := pb.Blog&#123;Name: \"hello c++\"&#125;id1, err := client.AddBlog(ctx, &amp;book1)if err != nil &#123; log.Fatalf(\"add book error %v\", err)&#125;log.Printf(\"book id %v\", id1.Id) GetBlog 123456//get blogget, err := client.GetBlog(ctx, id1)if err != nil &#123; log.Fatal(err)&#125;log.Printf(\"get blog %v\", get.Name) UpdateBlog 123456789101112131415&#x2F;&#x2F;update blogsstreamUpdateBlogs, err :&#x3D; client.UpdateBlog(ctx)if err !&#x3D; nil &#123; log.Fatal(err)&#125;streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: &quot;hahahhahaha&quot;&#125;)streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: &quot;zzzzzzzz&quot;&#125;)streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: &quot;hhhhhhhhhh&quot;&#125;)s, err :&#x3D; streamUpdateBlogs.CloseAndRecv()if err !&#x3D; nil &#123; log.Fatal(err)&#125;log.Printf(&quot;%v&quot;, s.Value) SearchBlog 123456789101112131415//update blogs streamUpdateBlogs, err := client.UpdateBlog(ctx)if err != nil &#123; log.Fatal(err)&#125;streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: \"hahahhahaha\"&#125;)streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: \"zzzzzzzz\"&#125;)streamUpdateBlogs.Send(&amp;pb.Blog&#123;Id: id1.Id, Name: \"hhhhhhhhhh\"&#125;)s, err := streamUpdateBlogs.CloseAndRecv()if err != nil &#123; log.Fatal(err)&#125;log.Printf(\"%v\", s.Value) AddBlogs 1234567891011121314151617181920212223242526272829303132333435363738 //add blogs test streamAddBlogs, err := client.AddBlogs(ctx) waitChanl := make(chan struct&#123;&#125;) go asncClientRPC(streamAddBlogs, waitChanl) if err != nil &#123; log.Fatalf(\"add books stream %v\", err) &#125; if err := streamAddBlogs.Send(&amp;pb.Blog&#123;Name: \"hello go\"&#125;); err != nil &#123; log.Fatalf(\"add books error %v\", err) &#125; if err := streamAddBlogs.Send(&amp;pb.Blog&#123;Name: \"hello c\"&#125;); err != nil &#123; log.Fatalf(\"add books error %v\", err) &#125; if err := streamAddBlogs.Send(&amp;pb.Blog&#123;Name: \"hello java\"&#125;); err != nil &#123; log.Fatalf(\"add books error %v\", err) &#125; if err != streamAddBlogs.CloseSend() &#123; log.Fatal(err) &#125; waitChanl &lt;- struct&#123;&#125;&#123;&#125;func asncClientRPC(streamAddBooks pb.BlogManagement_AddBlogsClient, c chan struct&#123;&#125;) &#123; for &#123; book_id, err := streamAddBooks.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatalf(\"asncClientRPC func error %v\", err) &#125; log.Printf(\"books id %v\", book_id.Id) &#125; &lt;-c&#125; main.py 123456789101112131415const ( address = \"localhost:8000\")func main() &#123;conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil &#123; log.Fatalf(\"connect error %v \", err) &#125; defer conn.Close() client := pb.NewBlogManagementClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() //..others...&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"grpc","slug":"grpc","permalink":"http://yoursite.com/tags/grpc/"}]},{"title":"grpc学习笔记(Go实现)服务端","slug":"grpc学习笔记-Go实现-服务端","date":"2021-09-14T12:06:05.000Z","updated":"2021-09-14T12:28:07.170Z","comments":true,"path":"2021/09/14/grpc学习笔记-Go实现-服务端/","link":"","permalink":"http://yoursite.com/2021/09/14/grpc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Go%E5%AE%9E%E7%8E%B0-%E6%9C%8D%E5%8A%A1%E7%AB%AF/","excerpt":"grpc学习笔记(Go实现)服务端","text":"grpc学习笔记(Go实现)服务端 protobuf文件的定义 123456789101112131415161718192021222324252627syntax = \"proto3\";package protoinfo;option go_package=\"blog-grpc/sevice/protoinfo\";message Blog&#123; string id = 1; string name = 2;&#125;message BlogID&#123; string id = 1;&#125;message StringValue&#123; string value = 1;&#125;service BlogManagement&#123; rpc AddBlog (Blog) returns (BlogID); rpc GetBlog (BlogID) returns (Blog); //服务端流式prc rpc SearchBlog (StringValue) returns (stream Blog); //客户端流式rpc rpc UpdateBlog (stream Blog) returns (StringValue); //双向流式RPC rpc AddBlogs (stream Blog) returns (stream BlogID);&#125; 服务端方法实现 AddBlog 1234567891011121314func (s *Server) AddBlog(ctx context.Context, in *pb.Blog) (*pb.BlogID, error) &#123; out, err := uuid.NewV4() if err != nil &#123; log.Fatalf(\"set id error %v\", err) return nil, status.Errorf(codes.Internal, \"set id error\", err) &#125; in.Id = out.String() if s.blogMap == nil &#123; s.blogMap = make(map[string]*pb.Blog) &#125; s.blogMap[in.Id] = in log.Printf(\"add blog %v\", in.Name) return &amp;pb.BlogID&#123;Id: in.Id&#125;, status.New(codes.OK, \"\").Err()&#125; GetBlog 1234567func (s *Server) GetBlog(ctx context.Context, in *pb.BlogID) (*pb.Blog, error) &#123; if out, ok := s.blogMap[in.Id]; ok &#123; return out, status.New(codes.OK, \"\").Err() &#125; else &#123; return nil, status.Error(codes.NotFound, \"not found\") &#125;&#125; SearchBlog 12345678910111213//server streamfunc (s *Server) SearchBlog(searchValue *pb.StringValue, stream pb.BlogManagement_SearchBlogServer) error &#123; for key, blog := range s.blogMap &#123; if strings.Contains(blog.Name, searchValue.Value) &#123; err := stream.Send(blog) if err != nil &#123; return fmt.Errorf(\"error send message stream %v\", err) &#125; log.Print(\"find the key: \" + key + \"blog: \" + blog.Name) &#125; &#125; return nil&#125; UpdateBlog 1234567891011121314//service streamfunc (s *Server) UpdateBlog(stream pb.BlogManagement_UpdateBlogServer) error &#123; for &#123; blog, err := stream.Recv() if err == io.EOF &#123; return stream.SendAndClose(&amp;pb.StringValue&#123;Value: \"update end\"&#125;) &#125; if err != nil &#123; return err &#125; s.blogMap[blog.Id] = blog log.Printf(\"update id: %v \\n name: %v\", blog.Id, blog.Name) &#125;&#125; AddBlogs 1234567891011121314151617181920212223//bi streamfunc (s *Server) AddBlogs(stream pb.BlogManagement_AddBlogsServer) error &#123; for &#123; blog, err := stream.Recv() if err == io.EOF &#123; return nil &#125; if err != nil &#123; return err &#125; out, err := uuid.NewV4() if err != nil &#123; return status.Errorf(codes.Internal, \"\", err) &#125; blog.Id = out.String() s.blogMap[blog.Id] = blog log.Printf(\"add blogs %v\", blog.Name) if err := stream.Send(&amp;pb.BlogID&#123;Id: blog.Id&#125;); err != nil &#123; return err &#125; &#125;&#125; main.go 12345678910111213141516const ( port = \"localhost:8000\")func main() &#123; lis, err := net.Listen(\"tcp\", port) if err != nil &#123; log.Printf(\"FIAL TO LISTEN %v\", err) &#125; s := grpc.NewServer() pb.RegisterBlogManagementServer(s, &amp;ma.Server&#123;&#125;) log.Printf(\"start serve on %v\", port) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"fail tp serve %v\", err) &#125;&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"grpc","slug":"grpc","permalink":"http://yoursite.com/tags/grpc/"}]},{"title":"django实现websocket服务器3","slug":"django实现websocket服务器3","date":"2021-09-10T12:31:21.000Z","updated":"2021-09-14T12:08:05.368Z","comments":true,"path":"2021/09/10/django实现websocket服务器3/","link":"","permalink":"http://yoursite.com/2021/09/10/django%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1%E5%99%A83/","excerpt":"通过django的channels实现了一个websocket服务器的总结与感想","text":"通过django的channels实现了一个websocket服务器的总结与感想 django实现websocket服务器2 接上文《用django实现websocket服务器2》 我们在实现了一个websocket服务器后我们就要进行相应的前后端测试环节。 这里我们前端使用如下简单的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function WebSocketTest() &#123; if (\"WebSocket\" in window) &#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket const ws = new WebSocket(\"ws://localhost:9000/ws/chat/lol/\"); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 const message = 'test-message' ws.send(JSON.stringify(&#123; 'message': message &#125;)); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (e) &#123; var received_msg = e.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"sse\"&gt; &lt;a href=\"javascript:WebSocketTest()\"&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里我们可以看到前端对于websocket对象有如下代码 onopen onmessage onclose send 来对应 连接建立，接收信息，关闭连接，发送信息 这几个情况。 也与之前channels中consumer的基本操作 connnect receive diconnect send形成了对应。 服务端与客户端建立起链接之后便处于一个对等的位置状态。","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"django实现websocket服务器2","slug":"django实现websocket服务器2","date":"2021-09-10T01:12:49.000Z","updated":"2021-09-10T01:47:02.464Z","comments":true,"path":"2021/09/10/django实现websocket服务器2/","link":"","permalink":"http://yoursite.com/2021/09/10/django%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1%E5%99%A82/","excerpt":"学习使用django利用channels来实现一个简易的websocket服务器(2)","text":"学习使用django利用channels来实现一个简易的websocket服务器(2) django实现websocket服务器2 routing channels的路由处理不在常规的django应用的views.py和urls.py中，而是一般是通过consumers.py和routings.py来进行路由处理。同时它的路由也是支持嵌套格式的，同时我们一般在根目录下asgi.py添加相应的相应的路由。 asgi.py 项目配置目录下 12345678910111213141516171819# mysite/asgi.pyimport osfrom channels.auth import AuthMiddlewareStackfrom channels.routing import ProtocolTypeRouter, URLRouterfrom django.core.asgi import get_asgi_applicationimport chat.routingsos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"chatserver.settings\")application = ProtocolTypeRouter(&#123; \"http\": get_asgi_application(), \"websocket\": AuthMiddlewareStack( URLRouter( #我们在这里添加项目的路由 chat.routings.websocket_urlpatterns ) ),&#125;) routings.py 对应应用目录下 12345678# chat/routing.pyfrom django.urls import re_pathfrom . import consumerswebsocket_urlpatterns = [ re_path(r'ws/chat/(?P&lt;room_name&gt;\\w+)/$',consumers.ChatConsumer.as_asgi()),] 总体路由操作与普通的urls.py操作也是类似的。 演示代码来自于https://channels.readthedocs.io/en/stable/","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"django实现websocket服务器1","slug":"django实现websocket服务器1","date":"2021-09-09T14:36:02.000Z","updated":"2021-09-10T12:59:31.068Z","comments":true,"path":"2021/09/09/django实现websocket服务器1/","link":"","permalink":"http://yoursite.com/2021/09/09/django%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1%E5%99%A81/","excerpt":"学习使用django利用channels来实现一个简易的websocket服务器(1)","text":"学习使用django利用channels来实现一个简易的websocket服务器(1) django实现websocket服务器1 最近参与的外包项目中提到了创建一个客服服务的需求，如果采用前端轮询服务器，过多的访问话会服务器产生较大的开销。于是就想到了利用webscoket协议尝试进行实现。以下是学习的一些笔记。 不同于普通的HTTP请求使用的WSGI，websocket要使用ASGI,使用异步调用来进行长连接。 channels.consumer channels为我们提供一个consumer的抽象，是我们更好使用ASGI程序。 consumer有两种类型，AsyncConsumer和SyncConsumer。 这是一个使用继承WebsocketConsumer同步消费者视图的简单实现例子，我们要关注不同阶段如connect，diconnect，receive这几个函数。 1234567891011121314151617import jsonfrom channels.generic.websocket import WebsocketConsumerclass ChatConsumer(WebsocketConsumer): def connect(self): self.accept() def disconnect(self, close_code): pass def receive(self, text_data): text_data_json = json.loads(text_data) message = text_data_json['message'] self.send(text_data=json.dumps(&#123; 'message': message &#125;)) 对于后端来说，添加类似代码将通道名存入数据库，在websocket创建时将它的通道名self.channel_name保存，发送时调用channel_layer.send( 通道名，… )即可完成信息的发送。 1“Clients.objects.create(channel_name=self.channel_name)” channel_layers 有时我们想要创建一个类似于群聊的东西。这时候我们就要使用通道层来实现不同通道间的通讯。即为实现一个聊天室。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# chat/consumers.pyimport jsonfrom asgiref.sync import async_to_syncfrom channels.generic.websocket import WebsocketConsumerclass ChatConsumer(WebsocketConsumer): def connect(self): self.room_name = self.scope['url_route']['kwargs']['room_name'] self.room_group_name = 'chat_%s' % self.room_name # Join room group async_to_sync(self.channel_layer.group_add)( self.room_group_name, self.channel_name ) self.accept() def disconnect(self, close_code): # Leave room group async_to_sync(self.channel_layer.group_discard)( self.room_group_name, self.channel_name ) # Receive message from WebSocket def receive(self, text_data): text_data_json = json.loads(text_data) message = text_data_json['message'] # Send message to room group async_to_sync(self.channel_layer.group_send)( self.room_group_name, &#123; 'type': 'chat_message', 'message': message &#125; ) # Receive message from room group def chat_message(self, event): message = event['message'] # Send message to WebSocket self.send(text_data=json.dumps(&#123; 'message': message &#125;)) 利用channel_layers我们可以实现通过send和group_send来实现访问不同的websocket通道，来实现单独发送和群发。而不是仅限于对于consumer的操作。 演示代码来自于https://channels.readthedocs.io/en/stable/","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"django中间件","slug":"django中间件","date":"2021-04-05T15:06:59.000Z","updated":"2021-09-09T15:54:30.391Z","comments":true,"path":"2021/04/05/django中间件/","link":"","permalink":"http://yoursite.com/2021/04/05/django%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"django中多对多的实现","slug":"django中多对多的实现","date":"2021-01-25T12:50:57.000Z","updated":"2021-01-25T13:30:44.961Z","comments":true,"path":"2021/01/25/django中多对多的实现/","link":"","permalink":"http://yoursite.com/2021/01/25/django%E4%B8%AD%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"django实现一对多和多对多关系 在使用django项目开发一个简单的api过程中遇到了小小的问题。 1.一个城市有许多的游玩方案（一对多关系） 2.每个游玩方案对应不同的景点（多对多关系） 3.每个游玩方案有不同的酒店（多对多关系）","text":"django实现一对多和多对多关系 在使用django项目开发一个简单的api过程中遇到了小小的问题。 1.一个城市有许多的游玩方案（一对多关系） 2.每个游玩方案对应不同的景点（多对多关系） 3.每个游玩方案有不同的酒店（多对多关系） 这里采用的是django框架给定的模型字段，没有另外设计 一对多关系 一个城市有着不同的游玩方案，则需要在游玩方案中加入ForeignKey字段，来对应相应的城市。 如果要创建一个递归关系 – 一个与其自身有多对一关系的对象 – 则使用 models.ForeignKey(&#39;self&#39;, on_delete=models.CASCADE)。 1234567CASCADEclass cityModel(models.Model): city_id = models.IntegerField('city_id',primary_key=True) city_name = models.CharField('city_name',max_length=255) class spot_list(models.Model): #使用ForeignKey字段添加关系 spotlist_id = models.ForeignKey(cityModel,on_delete=CASCADE) 关于on_delete值从官网截取一段介绍 CASCADE¶ Cascade deletes. Django emulates the behavior of the SQL constraint ON DELETE CASCADE and also deletes the object containing the ForeignKey.Model.delete() isn’t called on related models, but the pre_delete and post_delete signals are sent for all deleted objects. PROTECT¶ Prevent deletion of the referenced object by raising ProtectedError, a subclass of django.db.IntegrityError. SET_NULL¶ Set the ForeignKey null; this is only possible if null is True. SET_DEFAULT¶ Set the ForeignKey to its default value; a default for the ForeignKey must be set. SET()¶ *Set the ForeignKey to the value passed to SET(), or if a callable is passed in, the result of calling it. In most cases, passing a callable will be necessary to avoid executing queries at the time your models.py is imported: 123456789101112from django.conf import settingsfrom django.contrib.auth import get_user_modelfrom django.db import modelsdef get_sentinel_user(): return get_user_model().objects.get_or_create(username='deleted')[0]class MyModel(models.Model): user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user), ) DO_NOTHING¶ Take no action. If your database backend enforces referential integrity, this will cause an IntegrityError unless you manually add an SQL ON DELETE constraint to the database field 多对多关系 每个游玩方案有不同的酒店，可以使用ManyToManyField字段来创建 1234567891011121314151617181920class houseModel(models.Model): house_id = models.IntegerField('house_id',primary_key=True) house_name = models.CharField('house_name',max_length=255,default='无数据') house_locate = models.CharField('house_locate',max_length=255,default='无数据') house_image = models.ImageField('house_image',upload_to='images/house',default='images.jpg') house_prize = models.IntegerField('house_prize')class cityModel(models.Model): city_id = models.IntegerField('city_id',primary_key=True) city_name = models.CharField('city_name',max_length=255)class spot_list(models.Model): spotlist_id = models.ForeignKey(cityModel,on_delete=) #添加ManyToManyField字段 houselist = models.ManyToManyField(houseModel) 使用ForeignKey实现多对多关系 ​ 每个游玩方案对应不同的景点，但是景点有次序和浏览天数，直接使用ManyToManyField字段是无法直接访问到天数字段的。 ​ 这时我们可以利用ForeignKey来实现，即新建一个表，表中使用外键将两个表连接起来。 123456class spotlist_spot(models.Model): #on_delete=models.PROTECT，不要使用级联删除等方式。 spotlist_id = models.ForeignKey(spotlist,on_delete=models.PROTECT) spotmodel_id = models.ForeignKey(spotModel,on_delete=models.PROTECT) #这样我们就可以直接访问到天数了 list_day = models.IntegerField('list_day',default=0) 其实如果我们从数据库生成的表单来看，用ManyToManyField字段来创建数据库时都是会额外生成一个用于关联的表单，而使用ForeignKey实现多对多关系，就是相当于手动创建了一个用于关联的表单。","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"用matlab训练一个BP神经网络","slug":"用matlab训练一个BP神经网络","date":"2021-01-24T09:17:16.000Z","updated":"2021-01-24T09:23:37.981Z","comments":true,"path":"2021/01/24/用matlab训练一个BP神经网络/","link":"","permalink":"http://yoursite.com/2021/01/24/%E7%94%A8matlab%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AABP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"BP神经网络 是一种按照误差逆向传播算法训练的多层前馈神经网络，是应用最广泛的神经网络。","text":"BP神经网络 是一种按照误差逆向传播算法训练的多层前馈神经网络，是应用最广泛的神经网络。 人工神经网络无需事先确定输入输出之间映射关系的数学方程，仅通过自身的训练，学习某种规则，在给定输入值时得到最接近期望输出值的结果。作为一种智能信息处理系统，人工神经网络实现其功能的核心是算法。BP神经网络是一种按误差反向传播(简称误差反传)训练的多层前馈网络，其算法称为BP算法，它的基本思想是梯度下降法，利用梯度搜索技术，以期使网络的实际输出值和期望输出值的误差均方差为最小。 基本BP算法包括信号的前向传播和误差的反向传播两个过程。即计算误差输出时按从输入到输出的方向进行，而调整权值和阈值则从输出到输入的方向进行。正向传播时，输入信号通过隐含层作用于输出节点，经过非线性变换，产生输出信号，若实际输出与期望输出不相符，则转入误差的反向传播过程。误差反传是将输出误差通过隐含层向输入层逐层反传，并将误差分摊给各层所有单元，以从各层获得的误差信号作为调整各单元权值的依据。通过调整输入节点与隐层节点的联接强度和隐层节点与输出节点的联接强度以及阈值，使误差沿梯度方向下降，经过反复学习训练，确定与最小误差相对应的网络参数(权值和阈值)，训练即告停止。此时经过训练的神经网络即能对类似样本的输入信息，自行处理输出误差最小的经过非线形转换的信息。 BP网络是在输入层与输出层之间增加若干层(一层或多层)神经元，这些神经元称为隐单元，它们与外界没有直接的联系，但其状态的改变，则能影响输入与输出之间的关系，每一层可以有若干个节点。 BP神经网络的计算过程由正向计算过程和反向计算过程组成。正向传播过程，输入模式从输入层经隐单元层逐层处理，并转向输出层，每～层神经元的状态只影响下一层神经元的状态。如果在输出层不能得到期望的输出，则转入反向传播，将误差信号沿原来的连接通路返回，通过修改各神经元的权值，使得误差信号最小。 1．网络状态初始化 2．前向计算过程 首先使用newff函数建立一个BP神经网络 1net = newff(PR,[S1,S2,...SN],&#123;TF1,TF2&#125;,BTF,BLF,PF) PR : Rx2矩阵，定义输入向量的最大最小值 Si : 第i层神经元个数 TF : 传递函数 BTF : 训练函数 BLF ： 权值/阈值学习函数 PF : 性能函数 设置相关的训练参数 1234net.trainParam.show = 10; %显示间隔次数net.trainParam.lr = 0.05; %学习率，决定收敛速度 ，收敛效果net.trainParam.goal = 1e-10; %训练目标net.trainParam.epochs = 50000; %训练次数 算法的选择 12345678910111213141516171819202122232425262728293031323334353637net.trainFcn = 'traingd'; % 梯度下降算法net.trainFcn = 'traingdm'; % 动量梯度下降算法net.trainFcn = 'traingda'; % 变学习率梯度下降算法net.trainFcn = 'traingdx'; % 变学习率动量梯度下降算法% (大型网络的首选算法)net.trainFcn = 'trainrp'; % RPROP(弹性BP)算法,内存需求最小% 共轭梯度算法net.trainFcn = 'traincgf'; %Fletcher-Reeves修正算法net.trainFcn = 'traincgp'; %Polak-Ribiere修正算法,内存需求比Fletcher-Reeves修正算法略大net.trainFcn = 'traincgb'; % Powell-Beal复位算法,内存需求比Polak-Ribiere修正算法略大% (大型网络的首选算法)net.trainFcn = 'trainscg'; % ScaledConjugate Gradient算法,内存需求与Fletcher-Reeves修正算法相同,计算量比上面三种算法都小很多net.trainFcn = 'trainbfg'; %Quasi-Newton Algorithms - BFGS Algorithm,计算量和内存需求均比共轭梯度算法大,但收敛比较快net.trainFcn = 'trainoss'; % OneStep Secant Algorithm,计算量和内存需求均比BFGS算法小,比共轭梯度算法略大% (中型网络的首选算法)net.trainFcn = 'trainlm'; %Levenberg-Marquardt算法,内存需求最大,收敛速度最快net.trainFcn = 'trainbr'; % 贝叶斯正则化算法 有代表性的五种算法为:'traingdx','trainrp','trainscg','trainoss', 'trainlm'%在这里一般是选取'trainlm'函数来训练，其算对对应的是Levenberg-Marquardt算法 传入数据开始训练 1net = train(net,p,goal);%net网络模型 p输入数据 goal期望输出 对模型进行预测 1y=sim(net,x) 实例代码 123456789101112131415161718clearp1=[1.24,1.27;1.36,1.74;1.38,1.64;1.38,1.82;1.38,1.90;1.40,1.70;1.48,1.82;1.54,1.82;1.56,2.08];p2=[1.14,1.82;1.18,1.96;1.20,1.86;1.26,2.001.28,2.00;1.30,1.96];p=[p1;p2]';pr=minmax(p);goal=[ones(1,9),zeros(1,6);zeros(1,9),ones(1,6)];plot(p1(:,1),p1(:,2),'h',p2(:,1),p2(:,2),'o')net=newff(pr,[3,2],&#123;'logsig','logsig'&#125;);net.trainParam.show = 10;net.trainParam.lr = 0.05;net.trainParam.goal = 1e-10;net.trainParam.epochs = 50000;net = train(net,p,goal);x=[1.24 1.80;1.28 1.84;1.40 2.04]';y0=sim(net,p)y=sim(net,x)","categories":[{"name":"数模竞赛笔记","slug":"数模竞赛笔记","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}]},{"title":"我的2020与2021","slug":"我的2020与2021","date":"2021-01-01T06:25:43.000Z","updated":"2021-01-01T07:18:52.454Z","comments":true,"path":"2021/01/01/我的2020与2021/","link":"","permalink":"http://yoursite.com/2021/01/01/%E6%88%91%E7%9A%842020%E4%B8%8E2021/","excerpt":"2020年算是比较特殊的一年吧，发生了许许多多的事情。","text":"2020年算是比较特殊的一年吧，发生了许许多多的事情。 2020我做了什么有趣的事？ 购买服务器搭建自己的博客。 购置树莓派并进行折腾。 尝试不同的linux发行版，manjaro，ubuntu，deepin……. 参加工作室项目，用django编写后端并完成任务。 结识新的志同道合的朋友。 追番 ​ 《超炮》《RE:0》《公主连结》《辉夜》《成神》《魔女之旅》《春物》 补番 ​ 《地下城邂逅》《机器人笔记》《relife》《Re:creator》《路人女主》 打游戏 ​ 《原神》《CSGO》《求生之路》《OSU!》《战争雷霆》《崩崩崩》 2021我又准备去做什么呢？ 第一次感觉到过去的一年充满了遗憾。在番剧里《春物》《刀剑》《成神》一个一个打破了大家对神作的幻想。在现实中，一次一次的刷新历史的事件也在不断发生。对与自己的发展，我也在不断的摸索与碰壁。不管怎么说2020这一年，我又成功的划水划了过来。虽然有些遗憾但就让今年的我用发展，继续去解决吧。 今年可能要干的有趣的事情 工作室的小程序已经上线，但是还有许多功能尚没有完善，还得学习相关知识继续去完善。 数模竞赛的小队已经组建了起来，今年就要尝试去一起学习和参加比赛了。 继续折腾我的树莓派。 后端除了用python也想尝试一下go语言。 今年还会干的有趣的事情 ​ 追番，补番，打游戏","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"荔枝派天坑(一)","slug":"荔枝派天坑-一","date":"2020-09-02T04:42:17.000Z","updated":"2020-09-02T05:02:14.917Z","comments":true,"path":"2020/09/02/荔枝派天坑-一/","link":"","permalink":"http://yoursite.com/2020/09/02/%E8%8D%94%E6%9E%9D%E6%B4%BE%E5%A4%A9%E5%9D%91-%E4%B8%80/","excerpt":"第一次这么近距离接触linux内核，虽然基本失败了，但是也找到了一些解决方法，等有时间再重新尝试一下。争取打包出适配flash的镜像文件。","text":"第一次这么近距离接触linux内核，虽然基本失败了，但是也找到了一些解决方法，等有时间再重新尝试一下。争取打包出适配flash的镜像文件。 荔枝派天(填)坑(一) 2020/9/2 修改U-boot源代码适配 spi-flash xt25f128b(修改u-boot代码和内核代码，把ID加入)，并重新编译U-boot系统。(编译失败，待找解决方法) 使用buildroot编译linux的根文件系统。（成功） 编译linux的内核。(失败，可能是因为源码不完整) 等待后续","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"荔枝派","slug":"树莓派/荔枝派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E8%8D%94%E6%9E%9D%E6%B4%BE/"}],"tags":[{"name":"水果派","slug":"水果派","permalink":"http://yoursite.com/tags/%E6%B0%B4%E6%9E%9C%E6%B4%BE/"}]},{"title":"树莓派的自动小风扇","slug":"树莓派的自动小风扇","date":"2020-08-30T14:24:42.000Z","updated":"2020-08-31T12:34:33.990Z","comments":true,"path":"2020/08/30/树莓派的自动小风扇/","link":"","permalink":"http://yoursite.com/2020/08/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B0%8F%E9%A3%8E%E6%89%87/","excerpt":"装TTL接线的时候不小心把地线和5V输出引脚连了起来，一天的饭钱就这么没了。","text":"装TTL接线的时候不小心把地线和5V输出引脚连了起来，一天的饭钱就这么没了。 树莓派自动小风扇 起因：淘宝店给配的风扇转速强劲，声音过大，于是就想做个可以利用cpu温度控制的小电扇。 过程： 买配件，PNP三极管一个，子母杜邦线若干，母母杜邦线若干(其实买了一大堆)。 安装到电风扇调试（成功烧坏一天的饭钱）。 编写shell脚本，设置后台运行（nohup $），开机启动(rc.local在新版本的linux没有，开启有些麻烦，就使用crontab的@reboot设置来开机启动了)。 写博客吹水。 123456789101112131415#! /bin/bashsudo gpio mode 1 outputwhile [[1 == 1]]; do cputemp=`sudo cat /sys/class/thermal/thermal_zone0/temp` temp=$[ $cputemp/1000] if[[ &amp;temp &gt; 51]]; then sudo gpio write 1 0 fi if [[ $temp &lt;40 ]]; then sudo gpio white 1 1 fi #一个循环歇上4秒 sleep 4done","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"水果派","slug":"水果派","permalink":"http://yoursite.com/tags/%E6%B0%B4%E6%9E%9C%E6%B4%BE/"}]},{"title":"荔枝派!树莓派!开坑记录","slug":"荔枝派-树莓派","date":"2020-08-28T00:43:56.000Z","updated":"2020-08-28T01:40:06.520Z","comments":true,"path":"2020/08/28/荔枝派-树莓派/","link":"","permalink":"http://yoursite.com/2020/08/28/%E8%8D%94%E6%9E%9D%E6%B4%BE-%E6%A0%91%E8%8E%93%E6%B4%BE/","excerpt":"好久没有写博客了，之前入手了一枚 荔枝派nano，感觉自己目前技术驾驭不了，于是现在就入手了个 树莓派4B ，现在就先写个概要，记录一下之前填的坑和还没填的坑。","text":"好久没有写博客了，之前入手了一枚 荔枝派nano，感觉自己目前技术驾驭不了，于是现在就入手了个 树莓派4B ，现在就先写个概要，记录一下之前填的坑和还没填的坑。 荔枝派nano ​ 这算是我第一次接触的arm开发板，这块板子没有太多的资料，感觉对我这种新手极度不友好。不过通过第一次玩板子我第一了解到了flash，TTL串口，嵌入式主板引导程序Uboot，交叉编译工具链。 目前准备填的坑(咕): 将Uboot重新编译来完成对flash的分区，将linux装到flash上(之前是装到sd卡上的)。 学习qt或littleGL，尝试给开发板写个简单的可交互的图形界面。 尝试自己通过源码编译一下linux内核。 尝试用这个开发板音频解码，播放音乐和视频。 树莓派 ​ 有了荔枝派的铺垫，树莓派的操作就显得特别简单了，如手后先装了ubuntu-server，之后安装了nginx搭建起来了网站，顺便把自动填报得脚本也挂了上去。由于安装的是64位系统,WiringPi没有对应安装包，无法对引脚进行编程，于是在官方github下载源码重新编译了一个。 目前准备填的坑： 让树莓派通过wifi联网，由于用的是ubuntu的64位官方支持不是那么友好，尝试修改boot或直接连接都失败了(也可能是我wifi的问题)。 对引脚进行编程，尝试控制一下LED灯之类的小东西。 发现更多的新坑。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"荔枝派","slug":"树莓派/荔枝派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E8%8D%94%E6%9E%9D%E6%B4%BE/"}],"tags":[{"name":"水果派","slug":"水果派","permalink":"http://yoursite.com/tags/%E6%B0%B4%E6%9E%9C%E6%B4%BE/"}]},{"title":"重新写博客","slug":"重新更新博客","date":"2020-05-18T07:12:16.000Z","updated":"2020-05-23T09:20:09.761Z","comments":true,"path":"2020/05/18/重新更新博客/","link":"","permalink":"http://yoursite.com/2020/05/18/%E9%87%8D%E6%96%B0%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/","excerpt":"重新起航 和 一些关于Linux系统杂谈 ​ 之前的博客因为装Linux和Windows双系统把windows的一些给整坏了，数据全部都没了。","text":"重新起航 和 一些关于Linux系统杂谈 ​ 之前的博客因为装Linux和Windows双系统把windows的一些给整坏了，数据全部都没了。 所以以此为契机，不如重新写博客吧。之前的博客也都挺水的，没有太多的知识沉淀与总结。 题外话： 在Windows和Linux系统之间反复横跳的我最后理解了，系统之间并没有什么高下之分，只有自己用的舒服就好。Linux系统入坑前，总觉有种高大上的感觉。但最后觉得和Windows一样，都是只是一种生产力工具，要看自己用的舒服和运用领域了。 最后几句： ​ Ubuntu 20.04 LTS 默认桌面 gnome3.36 风格终于变的有现代感了，之前的gnome桌面感觉土里土气的o((&gt;ω&lt; ))o ​ deepin V20 也今年终于发布了，虽然 V15 使用过程中会出现奇怪的问题，但是deepin 个人感觉美化非常好，支持一波国产操作系统。deep-20-beta","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-18T05:16:08.413Z","updated":"2020-05-20T02:47:13.762Z","comments":true,"path":"2020/05/18/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"},{"name":"数模竞赛笔记","slug":"数模竞赛笔记","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"荔枝派","slug":"树莓派/荔枝派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/%E8%8D%94%E6%9E%9D%E6%B4%BE/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"grpc","slug":"grpc","permalink":"http://yoursite.com/tags/grpc/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"水果派","slug":"水果派","permalink":"http://yoursite.com/tags/%E6%B0%B4%E6%9E%9C%E6%B4%BE/"}]}